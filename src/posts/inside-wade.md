---
title: Inside Wade
date: July 16, 2017
order: 4
math: true
---

[Wade](https://github.com/KingPixil/wade) is a 1kb Javascript search library. It allows you to search for a query through a set of documents. This query is processed, split into keywords, and then searched within an index structure.

### API

The API is extremely minimal and self-explanatory. It looks like:

```js
const search = Wade(["He saves on socks.", "You are being silly."]);
search("save socks");
```

### Processor

Wade processes all documents and queries. This works by moving each item through a separate processing function. These do the following operations:

* Make everything lowercase.
  This helps with searching. All queries and data are made lowercase, resulting in the search not being case-sensitive.
* Remove punctuation.
  Punctuation is usually irrelevant to the search query and does not need to be searched for.
* Remove stop words.
  Wade has a list of stop words that are removed from all data and queries. Stop words are extra words that have little meaning or can apply to any item in the data, and removing them allows for more relevant results to be returned. These can be configured through `Wade.config.stopWords`.

### Index

After processing the data, an index can be generated to allow for optimized searches within a text. This index can be generated by:

1. Processing each document.
2. Splitting each document into a multiset of terms.
3. Generating a trie of the terms and storing the indexes of the corresponding documents containing the term.
4. Storing the weighted significance of the term in the documents.

A _set_ is used to store multiple unique items. The _cardinality_ of a set represents the amount of elements in the set.

On the other hand, a _multiset_ is used to store multiple items (including duplicates). The _multiplicity_ of an item in a multiset is the number of instances of that item in the multiset.

#### Significance

Wade uses a special function to find how significant a term is to the data. This function takes in many factors, including the length of the documents, the length of a specific document with the term, and the number of occurrences of the term.

The significance of the term _t_ in the set of documents _d_ can be represented by the function:

```math
wm(t, d) = 1.5 - \frac{\sum_{i=0}^{|d|} [\frac{\mu(t)}{\sum_{p \in d_i}(\mu(p))}]}{|d|}
```

1. `$f$` is a set of multisets `$d_i$`
2. `$t \in d_i$` for at least one `$d_i$`
3. `$\mu(t)$` is the multiplicity of `$t$` in the multiset `$d_i$`
4. `$\sum_{p \in d_i}(\mu(p))$` is the cardinality of the multiset `$d_i$`
5. `$\frac{\mu(t)}{\sum_{p \in d_i}(\mu(p))}$` is the ratio of occurrences of the term `$t$` in the document `$d_i$` to the total amount of terms in the document `$d_i$`

This works by finding the average of how often the term appears within a document. After this, the significance is normalized between `$0.5$` and `$1.5$`, allowing it to become higher when the average occurrence is lower. This allows for rarer terms to be amplified in significance.

### Search

When you first give Wade an array of data, it will create a [trie](https://en.wikipedia.org/wiki/Trie) representing all indexes of the data.

The best way to understand how this works is to use an example. Say that the data given looks like:

```js
["Hey", "Hello", "Greetings"]
```

After preprocessing, the data will look like:

```js
["hey", "hello", "greetings"]
```

The generated trie for this will have an array holding the indexes the of items that have the keyword.

```js
{
  "h": {
    "e": {
      "y": {
        "indexes": [0]
      },
      "l": {
        "l": {
          "o": {
            "indexes": [1]
          }
        }
      }
    }
  },
  "g": {
    "r": {
      "e": {
        "e": {
          "t": {
            "i": {
              "n": {
                "g": {
                  "s": {
                    "indexes": [2]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

As you can see, the trie will make a single data structure representing all of the strings. Whenever a node has had the content of a string so far, it will contain an `indexes` property holding the indexes in the data that the node refers to.

This data structure can take some time to generate, but searching through it is a breeze.

Say we would like to search for `"he"`. Wade will split this into keywords, and search for each of them in the trie individually, updating the score for the indexes as it goes.

Since there is only one keyword, Wade will treat it **as a prefix**, meaning that it will perform a [depth-first search](https://en.wikipedia.org/wiki/Depth-first_search).

This works by traveling as far down the trie as possible, and then grabbing the index of itself and _every_ node under it.

Let's go through this step by step. Wade will go through the keyword one by one, and see if it is in the trie.

1. The current character is `"h"`, it is inside of the trie, set the current node to it and continue.
2. The current character is `"e"`, set the current node to it.
3. We have arrived at the end of the keyword, check all nodes below.
4. Check `"y"`.
   The node has an `indexes` property, increment the score for the index inside (`[0]`).
5. Traverse through `"e"`, `"l"`, `"l"`, and `"o"`.
   The node has an `indexes` property, increment the score for the index inside (`[1]`).
6. Nothing left, abort the search.

In the end, we will be left with a `results` array like:

```js
[1, 1]
```

Both items have a score of `1`, hence the value of each item in the results array being `1`. The index of the item corresponds to the index in the data. Index `0` in the data (`"Hey"`) has a score of `1`, and index `1` in the data (`"Hello"`), has a score of `1`.

We can see that we have returned the results for:

```js
["Hey", "Hello"]
```

These both do indeed have the prefix of `"he"`, which means we have successfully performed a search! For keyword that aren't treated as prefixes, Wade will not perform a depth-first search, and will increment the score for any indexes found if the whole keyword was matched. The last keyword of a query will be treated as a prefix, as the user might still be typing.

### Conclusion

That is how Wade works! In a nutshell, it preprocesses data, splits it into keywords, and searches within a trie.

Be sure to check out the source on [Github](https://github.com/KingPixil/wade)
